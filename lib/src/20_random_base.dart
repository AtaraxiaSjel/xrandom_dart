// SPDX-FileCopyrightText: (c) 2021 Art Galkin <github.com/rtmigo>
// SPDX-License-Identifier: MIT

import 'dart:math';

import '00_errors.dart';
import '00_ints.dart';

@pragma('vm:prefer-inline')
double doornikNextFloat(int u32) {
  // https://www.doornik.com/research/randomdouble.pdf

  const M_RAN_INVM32 = 2.32830643653869628906e-010;
  return u32.uint32_to_int32() * M_RAN_INVM32 + 0.5;
}

abstract class RandomBase32 implements Random {
  /// Generates a non-negative random integer uniformly distributed in the range
  /// from 1 to 0xFFFFFFFF, both inclusive.
  ///
  /// It is the raw output of the generator.
  int nextInt32();

  /// Generates a non-negative random integer uniformly distributed in the range
  /// from 1 to 2^64-1, both inclusive.
  ///
  /// This method only works on VM. If you try to execute it in JS, an
  /// [Unsupported64Error] will be thrown.
  ///
  /// The raw numbers generated by the algorithm are 32-bit. This method
  /// combines two 32-bit numbers, placing the first number in the highest bytes
  /// of the 64-bit, and the second in the lowest bytes.
  ///
  /// Since the 32-bit generator never returns zero, after combining, neither
  /// the lowest 4 nor the highest 4 bytes of the number will be zero.
  @pragma('vm:prefer-inline')
  int nextInt64() {
    if (!INT64_SUPPORTED) {
      throw Unsupported64Error();
    }
    return (this.nextInt32() << 32) | this.nextInt32();
  }


  @override
  int nextInt(int max) {

    // based on dart:math https://git.io/JqCbB
    // (BSD) 2012, the Dart project authors

    const RANDMAX = 0xFFFFFFFF;
    const NUMRAND = RANDMAX + 1; //1 << 32; // 0x100000000
    const limit = 0x3FFFFFFF;
    if ((max <= 0) || ((max > limit) && (max > NUMRAND))) {
      throw RangeError.range(max, 1, NUMRAND, 'max');
    }

    var rnd32;
    var remainder;
    final cmp = NUMRAND - max;
    do {
      rnd32 = this.nextInt32();
      remainder = rnd32 % max;
    } while (rnd32 - remainder > cmp);
    return remainder;
  }


  //////////////////////////////////////////////////////////////////////////////
  // REMARKS to nextInt():
  //
  // In fact, we could climb a step higher: into the full range of UINT64.
  // The max argument allows you to set this. But the documentation
  // for the method will become somewhat perverse: what is nextInt(-2) ?!
  //
  //////////////////////////////////////////////////////////////////////////////

  /// Generates a non-negative random floating point value uniformly distributed
  /// in the range from 0.0, inclusive, to 1.0, exclusive.
  ///
  /// This method works faster than [nextDouble]. It sacrifices accuracy for speed.
  /// The result is mapped from a single 32-bit non-zero integer to [double].
  /// Therefore, the variability is limited by the number of possible values of
  /// such integer: 2^32-1 (= 4 294 967 295).
  ///
  /// This method uses the conversion suggested by J. Doornik in "Conversion of
  /// high-period random numbers to floating point" (2005).
  double nextFloat() {
    // https://www.doornik.com/research/randomdouble.pdf
    const M_RAN_INVM32 = 2.32830643653869628906e-010;
    return nextInt32().uint32_to_int32() * M_RAN_INVM32 + 0.5;
  }

  //////////////////////////////////////////////////////////////////////////////
  // REMARKS to nextFloat():
  //
  // With 2.12.1 on AMD A9, there were no differences in the performance:
  //
  // | Time (lower is better) | nextFloat | nextFloatUint | nextFloatInline |
  // |------------------------|-----------|---------------|-----------------|
  // | Xorshift32             |    370    |      379      |       373       |
  //
  // nextFloat:
  //    x.uint32_to_int32()*M_RAN_INVM32 + 0.5;
  // nextFloatInline:
  //    ( (x<=0x7fffffff)?x:(x-0x100000000) )*M_RAN_INVM32 + 0.5;
  // nextFloatUint:
  //    const FACTOR = 1 / UINT32_MAX;
  //    return (x - 1) * FACTOR
  //
  //////////////////////////////////////////////////////////////////////////////

  @override
  double nextDouble() {
    return nextInt32() * 2.3283064365386963e-10 + (nextInt32() >> 12) * 2.220446049250313e-16;
  }

  //////////////////////////////////////////////////////////////////////////////
  // REMARKS to nextDouble():
  //
  // This method is a bit slower, than ((x>>>11)*0x1.0p-53),
  // but it works in Node.js
  //
  // Vigna <https://prng.di.unimi.it/> suggests it like "Ð°n alternative,
  // multiplication-free conversion" of uint64_t to double like that:
  //
  // static inline double to_double(uint64_t x) {
  //   const union { uint64_t i; double d; } u
  //    = { .i = UINT64_C(0x3FF) << 52 | x >> 12 };
  //   return u.d - 1.0;
  // }
  //
  // The same technique used in Chrome's JavaScript V8 <https://git.io/Jqpma>:
  //
  // static inline double ToDouble(uint64_t state0) {
  //    // Exponent for double values for [1.0 .. 2.0)
  //    static const uint64_t kExponentBits = uint64_t{0x3FF0000000000000};
  //    uint64_t random = (state0 >> 12) | kExponentBits;
  //    return bit_cast<double>(random) - 1;
  // }
  //
  // Dart does not support typecasting of this kind.
  //
  // But here is how Madsen <https://git.io/JqWCP> does it in JavaScript:
  //   t2[0] * 2.3283064365386963e-10 + (t2[1] >>> 12) * 2.220446049250313e-16;
  // or
  //   t2[0] * Math.pow(2, -32) + (t2[1] >>> 12) * Math.pow(2, -52);
  //
  //////////////////////////////////////////////////////////////////////////////

  @override
  bool nextBool() {
    // we're returning bits from higher to lower: like uint32s from int64s
    if (_boolCache_prevShift == 0) {
      _boolCache = nextInt32();
      _boolCache_prevShift = 31;
      return _boolCache & 0x80000000 != 0;
    } else {
      assert(_boolCache_prevShift > 0);
      _boolCache_prevShift--;
      final result = (_boolCache & (1 << _boolCache_prevShift)) != 0;
      return result;
    }
  }

  int _boolCache = 0;
  int _boolCache_prevShift = 0;

//////////////////////////////////////////////////////////////////////////////
// REMARKS to nextBool():
//
// in dart:math it is return nextInt(2) == 0;
// which is an equivalent of
//   if ((2&-2)==2) return next()&(2-1);
//
// benchmarks 2021-03 with Xorshift32 (on Dell Seashell):
//    Random      (from dart:math)            2424
//    XorShift32  return nextInt(2)==0        2136
//    XorShift32  this.next() % 2 == 0        1903
//    XorShift32  this.next() >= 0x80000000   1821
//    XorShift32  returning bits              1423
//
//////////////////////////////////////////////////////////////////////////////
}

abstract class RandomBase64 extends RandomBase32 {
  /// Generates a non-negative random integer uniformly distributed in the range
  /// from 1 to 2^64-1, both inclusive.
  ///
  /// It is the raw output of the generator.
  @override
  int nextInt64();

  /// Generates a non-negative random integer uniformly distributed in the range
  /// from 0 to 0xFFFFFFFF, both inclusive.
  ///
  /// The raw numbers generated by the algorithm are 64-bit. This method returns
  /// the highest 32 bits, and then the lowest 32 bits of the generated numbers.
  ///
  /// Note that unlike the [RandomBase32.nextInt32], this overridden method
  /// can return 0.
  @override
  int nextInt32() {
    // we assume that the random generator never returns 0,
    // so 0 means "not initialized".
    if (_split64 == 0) {
      _split64 = this.nextInt64();

      // returning HIGHER four bytes
      const unsignedRightShift = 32;
      return (_split64 >> unsignedRightShift) & ~(-1 << (64 - unsignedRightShift)); // >>>

    } else {
      // we have a value: that means, we're already returned
      // the higher 4 bytes of it. Now we'll return the lower 4 bytes
      final result = _split64 & UINT32_MAX;
      _split64 = 0; // on the next call we'll need a new random here

      assert(result != 0);
      return result;
    }
  }

  int _split64 = 0;

  //////////////////////////////////////////////////////////////////////////////
  // REMARKS to nextInt32:
  //
  // In 32-bit generators, to get an int64, we use te FIRST four bytes as
  // the HIGHER, and the NEXT as the LOWER parts of int64. It's just because
  // most suggestions on the internet look like (rnd32()<<32)|rnd32().
  // That is, we have a conveyor like this:
  //
  // F1( FFFF, LLLL, FFFF, LLLL ) -> FFFFLLLL, FFFFLLLL
  //
  // In 64-bit generators, to split an int64 to two 32-bit integers, we want
  // the opposite, i.e.
  //
  // F2 ( FFFFLLLL, FFFFLLLL ) -> FFFF, LLLL, FFFF, LLLL
  //
  // So F1(F2(X))=X, F2(F1(Y))=Y.
  //
  // That's why we return highest bytes first, lowest bytes second
  //
  //////////////////////////////////////////////////////////////////////////////

  @override
  double nextDouble() {
    // the result of printf("%.60e", 0x1.0p-53):
    const double Z = 1.110223024625156540423631668090820312500000000000000000000000e-16;

    //_____(this.nextInt64()_>>>_11______________________)_*_0x1.0p-53
    return ((this.nextInt64() >> 11) & ~(-1 << (64 - 11))) * Z;
  }

  //////////////////////////////////////////////////////////////////////////////
  // REMARKS to nextDouble:
  //
  // we have a 64-bit integer to be converted to a float with only 53
  // significant bits.
  //
  // Vigna (https://prng.di.unimi.it/):
  //  64-bit unsigned integer x should be converted to a 64-bit double using
  //  the expression
  //    (x >> 11) * 0x1.0p-53
  //  In Java you can use almost the same expression for a (signed)
  //  64-bit integer:
  //    (x >>> 11) * 0x1.0p-53
  //
  //////////////////////////////////////////////////////////////////////////////

  @override
  bool nextBool() {
    // we're returning bits from higher to lower
    if (_boolCache_prevShift == 0) {
      _boolCache = nextInt64();
      _boolCache_prevShift = 63;
      return _boolCache < 0; // for the signed integer negative = highest bit set
    } else {
      assert(_boolCache_prevShift > 0);
      _boolCache_prevShift--;
      final result = (_boolCache & (1 << _boolCache_prevShift)) != 0;
      return result;
    }
  }

  /// Generates a non-negative random floating point value uniformly distributed
  /// in the range from 0.0, inclusive, to 1.0, exclusive.
  ///
  /// For the Dart this method is slower than [nextDouble] and has no
  /// advantages over [nextDouble].
  ///
  /// The results of this method exactly repeat the numbers usually generated
  /// by algorithms in C99 or C++. For example, this allows you to accurately
  /// reproduce the values of the generator used in the Chrome browser.
  ///
  /// In C99, the type conversion is described by S. Vigna as follows:
  ///
  /// ```
  /// static inline double to_double(uint64_t x) {
  ///   const union { uint64_t i; double d; } u = {
  ///     .i = UINT64_C(0x3FF) << 52 | x >> 12
  ///   };
  ///   return u.d - 1.0;
  /// }
  /// ```
  double nextDoubleBitcast() {
    // this is the same as RandomBase32.nextDouble()
    return nextInt32() * 2.3283064365386963e-10 + (nextInt32() >> 12) * 2.220446049250313e-16;
  }
}
