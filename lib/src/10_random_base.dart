// SPDX-FileCopyrightText: (c) 2021 Art Galkin <github.com/rtmigo>
// SPDX-License-Identifier: MIT

import 'dart:math';

import '00_errors.dart';
import '00_ints.dart';
import 'jsnumbers.dart';

@pragma('vm:prefer-inline')
double doornikNextFloat(int u32) {
  // https://www.doornik.com/research/randomdouble.pdf

  const M_RAN_INVM32 = 2.32830643653869628906e-010;
  return u32.uint32_to_int32()*M_RAN_INVM32 + 0.5;
}

abstract class RandomBase32 implements Random {
  /// Generates a non-negative random integer uniformly distributed in the range
  /// from 1 to 0xFFFFFFFF, both inclusive.
  ///
  /// It is the raw output of the generator.
  int nextInt32();

  /// Generates a non-negative random integer uniformly distributed in the range
  /// from 1 to 2^64-1, both inclusive.
  ///
  /// This method only works on VM. If you try to execute it in JS, an
  /// [Unsupported64Error] will be thrown.
  ///
  /// The raw numbers generated by the algorithm are 32-bit. This method
  /// combines two 32-bit numbers, placing the first number in the highest bytes
  /// of the 64-bit, and the second in the lowest bytes.
  ///
  /// Since the 32-bit generator never returns zero, after combining, neither
  /// the lowest 4 nor the highest 4 bytes of the number will be zero.
  int nextInt64() {
    if (!INT64_SUPPORTED) {
      throw Unsupported64Error();
    }
    return (this.nextInt32()<<32)|this.nextInt32();
  }

  /// Generates a non-negative random integer uniformly distributed in the range
  /// from 0, inclusive, to [max], exclusive.
  ///
  /// @param max The upper bound of the return value. For VM it can be any positive integer
  /// value greater than 0. For JS it must be 1 and (1<<32) inclusive.
  @override
  int nextInt(int max) {
    // 0x7FFFFFFFFFFFFFFF = 9223372036854775807 = (1<<63)-1 = 2^63-1,

    // constant represents the maximum safe integer in JavaScript (2^53)-1
    const JS_MAX_SAFE_INTEGER=9007199254740991;

    // todo support larger integers in JS

    if (max<1) {
      throw RangeError.range(max, 1, int.parse('0x7FFFFFFFFFFFFFFF'));
    }
    else if (max<=0xFFFFFFFF) {
      final rnd32 = nextInt32();
      assert(0 <= rnd32 && rnd32 <= UINT32_MAX);
      final result = rnd32 % max;
      assert(0 <= result && result < max);
      return result;
    } else if (max <= JS_MAX_SAFE_INTEGER) {
      // at least it fits into 53 bits. We can process it in JS without BigInt

      // https://en.wikipedia.org/wiki/Xoroshiro128%2B
      // "The lowest bits of the output generated by xoroshiro128+ have low quality."
      // https://en.wikipedia.org/wiki/Xorshift
      // "The scramblers known as + and * still leave weakness in the low bits"
      // okay, we'll use only higher 53 bits

      int rnd64 = INT64_SUPPORTED
          ? nextInt64().unsignedRightShift(11)
          : combineUpper53bitsJS(nextInt32(), nextInt32());

      assert(rnd64 > 0);
      assert(rnd64 <= JS_MAX_SAFE_INTEGER);

      final result = rnd64 % max;
      assert(0 <= result && result < max);
      return result;
    } else {
      assert(max > JS_MAX_SAFE_INTEGER);
      throw RangeError.range(max, 1, JS_MAX_SAFE_INTEGER);
    }

//
//       // - performance for the VM (we cannot guarantee anything with JS)
//
//
//
//
//       {
//       assert(max>=0x80000000);
//
//       if (INT64_SUPPORTED) {
//         // we are on WM
//         final rnd64 = nextInt64().unsetHighestBit64();
//         assert(rnd64>0);
//         final result = rnd64 % max;
//         assert(0 <= result && result < max);
//         return result;
//       } else {
//         // We are in JS, and [max] is huge (more than 32-bit).
//         // Now we need to get the 63-bit raw random and get the remainder
//         // of dividing it by [max]. But we cannot fit 63 bit into JS number,
//         // it's 53 bit only.
//
//         // This is probably not the fastest calculation method.
//         // But at the moment, I don't know any other way.
//         // The problem is to get the remainder of dividing a 63-bit number
//         // (the raw random) by [max]. But we cannot fit the raw random into
//         // a number in JS, since JS is limited by 53 bits.
//
//         var bi = (BigInt.from(nextInt32()&0x7FFFFFFF)<<32)|BigInt.from(nextInt32());
//         return (bi%BigInt.from(max)).toInt();
// //        assert(max<=JS_MAX_SAFE_INTEGER);
//   //      return combineLower53bitsJS(nextInt32(), nextInt32());
//       }
//    }
  }

  //////////////////////////////////////////////////////////////////////////////
  // REMARKS to nextInt():
  //
  // We could possibly imagine this method accepting even larger arguments
  // with the highest bit set.
  //
  // | Time (lower is better) | nextFloat | nextFloatUint | nextFloatInline |
  // |------------------------|-----------|---------------|-----------------|
  // | Xorshift32             |    370    |      379      |       373       |
  //
  // nextFloat:
  //    x.uint32_to_int32()*M_RAN_INVM32 + 0.5;
  // nextFloatInline:
  //    ( (x<=0x7fffffff)?x:(x-0x100000000) )*M_RAN_INVM32 + 0.5;
  // nextFloatUint:
  //    const FACTOR = 1 / UINT32_MAX;
  //    return (x - 1) * FACTOR
  //
  //////////////////////////////////////////////////////////////////////////////

  /// Generates a non-negative random floating point value uniformly distributed
  /// in the range from 0.0, inclusive, to 1.0, exclusive.
  ///
  /// This method works faster than [nextDouble]. It sacrifices accuracy for speed.
  /// The result is mapped from a single 32-bit non-zero integer to [double].
  /// Therefore, the variability is limited by the number of possible values of
  /// such integer: 2^32-1 (= 4 294 967 295).
  ///
  /// This method uses the conversion suggested by J. Doornik in "Conversion of
  /// high-period random numbers to floating point" (2005).
  double nextFloat() {
    // https://www.doornik.com/research/randomdouble.pdf
    // return doornikNextFloat(nextInt32());
    //

    const M_RAN_INVM32 = 2.32830643653869628906e-010;
    return nextInt32().uint32_to_int32()*M_RAN_INVM32 + 0.5;
  }

  //////////////////////////////////////////////////////////////////////////////
  // REMARKS to nextFloat():
  //
  // With 2.12.1 on AMD A9, there were no differences in the performance:
  //
  // | Time (lower is better) | nextFloat | nextFloatUint | nextFloatInline |
  // |------------------------|-----------|---------------|-----------------|
  // | Xorshift32             |    370    |      379      |       373       |
  //
  // nextFloat:
  //    x.uint32_to_int32()*M_RAN_INVM32 + 0.5;
  // nextFloatInline:
  //    ( (x<=0x7fffffff)?x:(x-0x100000000) )*M_RAN_INVM32 + 0.5;
  // nextFloatUint:
  //    const FACTOR = 1 / UINT32_MAX;
  //    return (x - 1) * FACTOR
  //
  //////////////////////////////////////////////////////////////////////////////

  @override
  double nextDouble() {
    return nextInt32() * 2.3283064365386963e-10 + (nextInt32() >> 12) * 2.220446049250313e-16;
  }

  //////////////////////////////////////////////////////////////////////////////
  // REMARKS to nextDouble():
  //
  // This method is a bit slower, than ((x>>>11)*0x1.0p-53),
  // but it works in Node.js
  //
  // Vigna <https://prng.di.unimi.it/> suggests it like "Ð°n alternative,
  // multiplication-free conversion" of uint64_t to double like that:
  //
  // static inline double to_double(uint64_t x) {
  //   const union { uint64_t i; double d; } u
  //    = { .i = UINT64_C(0x3FF) << 52 | x >> 12 };
  //   return u.d - 1.0;
  // }
  //
  // The same technique used in Chrome's JavaScript V8 <https://git.io/Jqpma>:
  //
  // static inline double ToDouble(uint64_t state0) {
  //    // Exponent for double values for [1.0 .. 2.0)
  //    static const uint64_t kExponentBits = uint64_t{0x3FF0000000000000};
  //    uint64_t random = (state0 >> 12) | kExponentBits;
  //    return bit_cast<double>(random) - 1;
  // }
  //
  // Dart does not support typecasting of this kind.
  //
  // But here is how Madsen <https://git.io/JqWCP> does it in JavaScript:
  //   t2[0] * 2.3283064365386963e-10 + (t2[1] >>> 12) * 2.220446049250313e-16;
  // or
  //   t2[0] * Math.pow(2, -32) + (t2[1] >>> 12) * Math.pow(2, -52);
  //
  //////////////////////////////////////////////////////////////////////////////

  @override
  bool nextBool() {
    // we're returning bits from higher to lower: like uint32s from int64s
    if (_boolCache_prevShift == 0) {
      _boolCache = nextInt32();
      _boolCache_prevShift = 31;
      return _boolCache & 0x80000000 != 0;
    } else {
      assert(_boolCache_prevShift > 0);
      _boolCache_prevShift--;
      final result = (_boolCache & (1 << _boolCache_prevShift)) != 0;
      return result;
    }
  }

  int _boolCache = 0;
  int _boolCache_prevShift = 0;

  //////////////////////////////////////////////////////////////////////////////
  // REMARKS to nextBool():
  //
  // in dart:math it is return nextInt(2) == 0;
  // which is an equivalent of
  //   if ((2&-2)==2) return next()&(2-1);
  //
  // benchmarks 2021-03 with Xorshift32 (on Dell Seashell):
  //    Random      (from dart:math)            2424
  //    XorShift32  return nextInt(2)==0        2136
  //    XorShift32  this.next() % 2 == 0        1903
  //    XorShift32  this.next() >= 0x80000000   1821
  //    XorShift32  returning bits              1423
  //
  //////////////////////////////////////////////////////////////////////////////
}

abstract class RandomBase64 extends RandomBase32 {
  /// Generates a non-negative random integer uniformly distributed in the range
  /// from 1 to 2^64-1, both inclusive.
  ///
  /// It is the raw output of the generator.
  @override
  int nextInt64();

  /// Generates a non-negative random integer uniformly distributed in the range
  /// from 0 to 0xFFFFFFFF, both inclusive.
  ///
  /// The raw numbers generated by the algorithm are 64-bit. This method returns
  /// the highest 32 bits, and then the lowest 32 bits of the generated numbers.
  ///
  /// Note that unlike the [RandomBase32.nextInt32], this overriden method
  /// can return 0.
  @override
  int nextInt32() {
    // we assume that the random generator never returns 0,
    // so 0 means "not initialized".
    if (_forNext32 == 0) {
      _forNext32 = this.nextInt64();

      // returning HIGHER four bytes
      // unsigned right shift
      const shift = 32;

      return _forNext32 >= 0
          ? _forNext32 >> shift
          : ((_forNext32 & INT64_MAX_POSITIVE) >> shift) | (1 << (63 - shift));

    } else {
      // we have a value: that means, we're already returned
      // the higher 4 bytes of it. Now we'll return the lower 4 bytes
      final result = _forNext32 & UINT32_MAX;
      _forNext32 = 0; // on the next call we'll a new random here

      // since the generator never returns 0, the lower bytes are already
      // guaranteed not to be 0
      assert(result!=0);
      return result;
    }
  }

  int _forNext32 = 0;

  //////////////////////////////////////////////////////////////////////////////
  // REMARKS to nextInt32:
  //
  // In 32-bit generators, to get an int64, we use te FIRST four bytes as
  // the HIGHER, and the NEXT as the LOWER parts of int64. It's just because
  // most suggestions on the internet look like (rnd32()<<32)|rnd32().
  // That is, we have a conveyor like this:
  //
  // F1( FFFF, LLLL, FFFF, LLLL ) -> FFFFLLLL, FFFFLLLL
  //
  // In 64-bit generators, to split an int64 to two 32-bit integers, we want
  // the opposite, i.e.
  //
  // F2 ( FFFFLLLL, FFFFLLLL ) -> FFFF, LLLL, FFFF, LLLL
  //
  // So F1(F2(X))=X, F2(F1(Y))=Y.
  //
  // That's why we return highest bytes first, lowest bytes second
  //
  //////////////////////////////////////////////////////////////////////////////

  @override
  double nextDouble() {
    // the result of printf("%.60e", 0x1.0p-53):
    const double Z = 1.110223024625156540423631668090820312500000000000000000000000e-16;

    //_____(this.nextInt64()_>>>_11______________________)_*_0x1.0p-53
    return ((this.nextInt64() >> 11) & ~(-1 << (64 - 11))) * Z;
  }

  //////////////////////////////////////////////////////////////////////////////
  // REMARKS to nextDouble:
  //
  // we have a 64-bit integer to be converted to a float with only 53
  // significant bits.
  //
  // Vigna (https://prng.di.unimi.it/):
  //  64-bit unsigned integer x should be converted to a 64-bit double using
  //  the expression
  //    (x >> 11) * 0x1.0p-53
  //  In Java you can use almost the same expression for a (signed)
  //  64-bit integer:
  //    (x >>> 11) * 0x1.0p-53
  //
  //////////////////////////////////////////////////////////////////////////////

  @override
  bool nextBool() {
    // we're returning bits from higher to lower
    if (_boolCache_prevShift == 0) {
      _boolCache = nextInt64();
      _boolCache_prevShift = 63;
      return _boolCache <
          0; // for the signed integer negative = highest bit set
    } else {
      assert(_boolCache_prevShift > 0);
      _boolCache_prevShift--;
      final result = (_boolCache & (1 << _boolCache_prevShift)) != 0;
      return result;
    }
  }

  /// Generates a non-negative random floating point value uniformly distributed
  /// in the range from 0.0, inclusive, to 1.0, exclusive.
  ///
  /// For the Dart this method is slower than [nextDouble] and has no
  /// advantages over [nextDouble].
  ///
  /// The results of this method exactly repeat the numbers usually generated
  /// by algorithms in C99 or C++. For example, this allows you to accurately
  /// reproduce the values of the generator used in the Chrome browser.
  ///
  /// In C99, the type conversion is described by S. Vigna as follows:
  ///
  /// ```
  /// static inline double to_double(uint64_t x) {
  ///   const union { uint64_t i; double d; } u = {
  ///     .i = UINT64_C(0x3FF) << 52 | x >> 12
  ///   };
  ///   return u.d - 1.0;
  /// }
  /// ```
  double nextDoubleBitcast() {
    // this is the same as RandomBase32.nextDouble()
    return nextInt32() * 2.3283064365386963e-10 +
        (nextInt32() >> 12) * 2.220446049250313e-16;
  }
}
