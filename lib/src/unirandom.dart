// SPDX-FileCopyrightText: (c) 2021 Art Galkin <ortemeo@gmail.com>
// SPDX-License-Identifier: BSD-3-Clause

import 'dart:math';
import 'ints.dart';

abstract class UniRandom implements Random {
  int next();

  @override
  bool nextBool() {
    return this.next() % 2 == 0;
  }

  /// Generates a non-negative random floating point value uniformly distributed
  /// in the range from [min], inclusive, to [max], exclusive.
  double nextDoubleInRange(num min, num max) {
    return min + ((max - min) * this.nextDouble());
  }

  int nextIntInRange(int min, int max) {
    return this.nextDoubleInRange(min, max).floor();
  }

  @override
  int nextInt(int max) {
    return this.nextIntInRange(0, max);
  }
}

abstract class UniRandom32_old extends UniRandom {
  @override
  double nextDouble() {
    int x = this.next();
    if (x > 0xFFFFFFFF || x <= 0)
      throw AssertionError("Unexpected 32-bit value generated by .next(): $x");

    // scaling x from (0, MAX_UINT32] to [0.0, 1.0).
    return (x - 1) / MAX_UINT32;
  }
}

abstract class UniRandom32 extends UniRandom {

  // https://git.io/JqCbB

  static const _POW2_32 = 1 << 32;
  static const _POW2_53_D = 1.0 * (1 << 53);
  static const _POW2_27_D = 1.0 * (1 << 27);

  @override
  int nextInt(int max) {

    const limit = 0x3FFFFFFF;
    if ((max <= 0) || ((max > limit) && (max > _POW2_32))) {
      throw new RangeError.range(
          max, 1, _POW2_32, "max", "Must be positive and <= 2^32");
    }

    if ((max & -max) == max) {
      // Fast case for powers of two.
      final rnd32 = this.next();
      assert(rnd32<=MAX_UINT32);
      return rnd32 & (max - 1);
    }

    var rnd32;
    var result;
    do {
      rnd32 = this.next();
      assert(rnd32<=MAX_UINT32);
      result = rnd32 % max;
    } while ((rnd32 - result + max) > _POW2_32);
    return result;
  }

  @override
  double nextDouble() {
    return ((nextInt(1 << 26) * _POW2_27_D) + nextInt(1 << 27)) / _POW2_53_D;
  }

  @override
  bool nextBool() {
    final rndUint32 = this.next();
    assert(0<=rndUint32 && rndUint32<=MAX_UINT32);
    return rndUint32 >= 0x80000000;
  }
}


abstract class UniRandom64 extends UniRandom {
  @override
  double nextDouble() {
    int x = this.next();

    if (x > INT64_MAX_POSITIVE)
      throw AssertionError("Unexpected 64-bit value generated by .next(): $x");
    else if (x < 0) x = x.unsetHighestBit64();
    assert(x >= 0);
    assert(x <= INT64_MAX_POSITIVE);

    // scaling x from (0, MAX_POSITIVE_INT64] to [0.0, 1.0).
    return (x - 1) / INT64_MAX_POSITIVE;
  }
}
