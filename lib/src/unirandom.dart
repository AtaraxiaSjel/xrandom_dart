// SPDX-FileCopyrightText: (c) 2021 Art Galkin <ortemeo@gmail.com>
// SPDX-License-Identifier: BSD-3-Clause

import 'dart:math';
import 'ints.dart';

// abstract class UniRandom implements Random {
//   int next();
//
//   @override
//   bool nextBool() {
//     return this.next() % 2 == 0;
//   }
//
//   /// Generates a non-negative random floating point value uniformly distributed
//   /// in the range from [min], inclusive, to [max], exclusive.
//   double nextDoubleInRange(num min, num max) {
//     return min + ((max - min) * this.nextDouble());
//   }
//
//   int nextIntInRange(int min, int max) {
//     return this.nextDoubleInRange(min, max).floor();
//   }
//
//   @override
//   int nextInt(int max) {
//     return this.nextIntInRange(0, max);
//   }
// }
//
// abstract class UniRandom32_old extends UniRandom {
//   @override
//   double nextDouble() {
//     int x = this.next();
//     if (x > 0xFFFFFFFF || x <= 0)
//       throw AssertionError("Unexpected 32-bit value generated by .next(): $x");
//
//     // scaling x from (0, MAX_UINT32] to [0.0, 1.0).
//     return (x - 1) / MAX_UINT32;
//   }
// }

/// Scales an integer from range `(1, MAX_UINT32]` to `[0.0, 1.0)` arithmetically.
double scaleUint32toDouble(int x)
{
  // kept here for reference. Not used for now
  if (x > 0xFFFFFFFF || x <= 0)
    throw RangeError.value(x);
  return (x - 1) / UINT32_MAX;
}

// /// Scales lower 63 bits of [x] to `[0.0, 1.0)` arithmetically.
// double scaleInt64toDouble(int x)
// {
//   // kept here for reference. Not used for now
//   if (x==0)
//     throw RangeError.value(x);
//   if (x < 0) x = x.unsetHighestBit64();
//   assert(x >= 0);
//   assert(x <= INT64_MAX_POSITIVE);
//
//   // scaling x from (0, MAX_POSITIVE_INT64] to [0.0, 1.0).
//   return (x - 1) / INT64_MAX_POSITIVE;
// }

abstract class UniRandom32 implements Random {

  // https://git.io/JqCbB

  static const _POW2_32 = 1 << 32;
  static const _POW2_53_D = 1.0 * (1 << 53);
  static const _POW2_27_D = 1.0 * (1 << 27);
  
  int next32();

  @override
  int nextInt(int max) {
    // slightly modified _Random.nextInt() from dart:math (https://git.io/JqCbB)

    const limit = 0x3FFFFFFF;
    if ((max <= 0) || ((max > limit) && (max > _POW2_32))) {
      throw new RangeError.range(
          max, 1, _POW2_32, "max", "Must be positive and <= 2^32");
    }

    if ((max & -max) == max) {
      // fast case for powers of two.
      final rnd32 = this.next32();
      assert(0<=rnd32 && rnd32<=UINT32_MAX);
      return rnd32 & (max - 1);
    }

    var rnd32;
    var result;
    do {
      rnd32 = this.next32();
      assert(0<=rnd32 && rnd32<=UINT32_MAX);
      result = rnd32 % max;
    } while ((rnd32 - result + max) > _POW2_32);
    return result;
  }

  @override
  double nextDouble() {
    // almost the same as _Random.nextDouble() from dart:math (https://git.io/JqCbB)
    // Here we're trying to be JavaScript-compatible
    return ((nextInt(1 << 26) * _POW2_27_D) + nextInt(1 << 27)) / _POW2_53_D;
  }

  //int _nextIntRaw() => this.next32();

  bool _nextBool(int getInt(), int bits)
  {
    if (_boolCache==0) {
      _boolCache = getInt();
      _boolCachePos = 0;
      return _boolCache&1 == 1;
    } else {
      ++_boolCachePos;
      final result = (_boolCache & (1<<_boolCachePos)) != 0;
      if (_boolCachePos==(bits-1))
        _boolCache = 0;
      return result;
    }
  }


  @override
  bool nextBool() {

    // in dart:math it is return nextInt(2) == 0;
    // which is an equivalent of
    //   if ((2&-2)==2) return next()&(2-1);

    // benchmarks 2021-03 with Xorshift32 (on Dell Seashell):
    //    Random      (from dart:math)            2424
    //    XorShift32  return nextInt(2)==0        2136
    //    XorShift32  this.next() % 2 == 0        1903
    //    XorShift32  this.next() >= 0x80000000   1821

    return this._nextBool(this.next32, 32);

    // if (_boolCache==0) {
    //   _boolCache = next32();
    //   _boolCachePos = 0;
    //   return _boolCache&1 == 1;
    // } else {
    //   ++_boolCachePos;
    //   final result = (_boolCache & (1<<_boolCachePos)) != 0;
    //   if (_boolCachePos==31)
    //     _boolCache = 0;
    //   return result;
    // }
  }

  int _boolCache = 0;
  int _boolCachePos = 0;
}

// enum SplitterState
// {
//  
// }


abstract class UniRandom64 extends UniRandom32 {

  int next64();
  
  int next32() {
    
    // we assume that the random generator never returns 0,
    // so 0 means "not initialized".
    
    if (_forNext32==0) {
      _forNext32 = this.next64();
      return _forNext32 & UINT32_MAX; // returning lower 4 bytes
    } else {
      // we have a value: that means, we're already returned
      // the lower 4 bytes of it. Now we'll return the higher 4 bytes

      final x = _forNext32;
      _forNext32 = 0; // on the next call we'll a new random here

      const shift = 32;
      // and here's our favorite unsigned right shift
      return x >= 0
          ? x >> shift
          : ((x & INT64_MAX_POSITIVE) >> shift) | (1 << (63 - shift));
    }
  }

  int _forNext32 = 0;

  
  @override
  double nextDouble() {
    // todo
    int x = this.next64();

    if (x > INT64_MAX_POSITIVE)
      throw AssertionError("Unexpected 64-bit value generated by .next(): $x");
    else if (x < 0) x = x.unsetHighestBit64();
    assert(x >= 0);
    assert(x <= INT64_MAX_POSITIVE);

    // scaling x from (0, MAX_POSITIVE_INT64] to [0.0, 1.0).
    return (x - 1) / INT64_MAX_POSITIVE;
  }

  @override
  bool nextBool() {

    return this._nextBool(this.next64, 64);
  }

  // @override
  // bool nextBool() {
  //
  //   final rnd = this.next64();
  //   return (rnd & 0x80000000)>0; // todo
  // }
}
